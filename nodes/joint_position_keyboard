#!/usr/bin/env python


import argparse

import rospy
import numpy as np
from intera_core_msgs.msg import JointCommand
import intera_external_devices
import intera_interface
from intera_interface import CHECK_VERSION
from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from std_srvs.srv import Empty, EmptyResponse
import pygame

import sympy as sp
from sympy import symbols, Eq, solve, init_printing, simplify, Function, Matrix

import kinpy as kp

# import intera_interface
# import intera_external_devices

# from intera_interface import CHECK_VERSION

class SawyerMove:

    def __init__(self) -> None:
        self.chain = kp.build_serial_chain_from_urdf(open("sawyer.urdf").read(), 'right_l6')
        self.joint_state_sub = rospy.Subscriber('/robot/joint_states', JointState, self.jss_callback)
        self.joint_action_pub = rospy.Publisher('/robot/limb/right/joint_command', JointCommand, queue_size=10)
        self.up_srv = rospy.Service("move_up", Empty, self.moveup_callback)
        self.curr_joint_pos = np.zeros(9)
        self.joint_names = []



        self.move_mag = 1.0
        self.vel_mag = 0.1
        self.yc = 0.4
        self.xc = 0.4


    def height_to_joints(self, height):
        #two links IK
        #wrist max_height = 0.4

        L1 = 0.4
        L4 = (126.5 + 273.5)/1000

        h_sq = (self.xc**2) + (height**2)
        b = np.arccos((h_sq - (L1**2) - (L4**2))/ (2*L1*L4))
        a = -(np.arccos((L4**2 - h_sq - L1**2)/(-2*np.sqrt(h_sq)*L1)) + np.arctan2(height,self.xc))
        c = (-a) + np.deg2rad(90) - b

        return b, a, c

    def jss_callback(self, data):
        self.curr_joint_pos = data.position
        self.joint_names = data.name

    def moveup_callback(self, emp):
        self.move_up()

        print("up")
        return EmptyResponse()


    def move_down(self, jac_f):
        if len(self.curr_joint_pos) == 0:
            print('joint angle not publishing yet')
            return

        jac_sub = jac_f(0.4,0.4,0.13375,self.curr_joint_pos[2],self.curr_joint_pos[4],self.curr_joint_pos[6])
        inv_jac = np.linalg.pinv(jac_sub)
        ee_vel_val = np.array([0.0, -0.3, 0.0]).reshape(-1,1)
        joint_vel_val = (inv_jac@ee_vel_val).flatten()
        a, b, c = joint_vel_val[0], joint_vel_val[1], joint_vel_val[2]
        print(a, b, c)


        # print("---")
        # jac2 = self.chain.jacobian(self.curr_joint_pos)
        # inv_jac2 = np.linalg.pinv(jac2)
        # joint_vel_val2 = (inv_jac2@np.array([0.0,-0.01,0.0,0.0,0.0,0.0]).reshape(-1,1)).flatten()
        # a2,b2,c2 = joint_vel_val2[0], joint_vel_val2[1], joint_vel_val2[2]
        # print(joint_vel_val2)
        # print("---")




        jc = JointCommand()
        jc.mode = 2
        jc.names = [self.joint_names[2], self.joint_names[4], self.joint_names[6]]

        # ## pos control
        # # print(self.curr_joint_pos[5])
        # # next_joint_pos = list(self.curr_joint_pos)
        # # next_joint_pos[5] -= 0.1
        # # jc.position = next_joint_pos

        ## vel control
        #joint_vel = np.zeros(9)
        joint_vel = np.zeros(3)
        joint_vel[1] = b
        joint_vel[0] = a
        joint_vel[2] = c
        jc.velocity = joint_vel

        # ## torque control
        # # joint_torque = np.zeros(9)
        # # joint_torque[4] = 2.0
        # # jc.effort = joint_torque
        
        self.joint_action_pub.publish(jc)

        ## pos control
        # jc_pos = JointCommand()
        # jc_pos.mode = 1
        # jc_pos.names = [self.joint_names[0], self.joint_names[1], self.joint_names[3], self.joint_names[5]]

        
        # next_joint_pos = np.zeros(4)
        # jc_pos.position = next_joint_pos
        # self.joint_action_pub.publish(jc_pos)


    def move_up(self, jac_f):
        if len(self.curr_joint_pos) == 0:
            print('joint angle not publishing yet')
            return

        jac_sub = jac_f(0.4,0.4,0.13375,self.curr_joint_pos[2],self.curr_joint_pos[4],self.curr_joint_pos[6])
        inv_jac = np.linalg.pinv(jac_sub)
        ee_vel_val = np.array([0.0, 0.3, 0.0]).reshape(-1,1)
        joint_vel_val = (inv_jac@ee_vel_val).flatten()
        a, b, c = joint_vel_val[0], joint_vel_val[1], joint_vel_val[2]
        print(a, b, c)



        jc = JointCommand()
        jc.mode = 2
        jc.names = [self.joint_names[2], self.joint_names[4], self.joint_names[6]]

        # ## pos control
        # # print(self.curr_joint_pos[5])
        # # next_joint_pos = list(self.curr_joint_pos)
        # # next_joint_pos[5] -= 0.1
        # # jc.position = next_joint_pos

        ## vel control
        #joint_vel = np.zeros(9)
        joint_vel = np.zeros(3)
        joint_vel[1] = b
        joint_vel[0] = a
        joint_vel[2] = c
        jc.velocity = joint_vel

        # ## torque control
        # # joint_torque = np.zeros(9)
        # # joint_torque[4] = 2.0
        # # jc.effort = joint_torque
        
        self.joint_action_pub.publish(jc)



        ## pos control
        # jc_pos = JointCommand()
        # jc_pos.mode = 1
        # jc_pos.names = [self.joint_names[0], self.joint_names[1], self.joint_names[3], self.joint_names[5]]

        
        # next_joint_pos = np.zeros(4)
        # jc_pos.position = next_joint_pos
        # self.joint_action_pub.publish(jc_pos)


def calculate_jac():

    L1,L4,L6, t, dxe, dye, dphie, da, db, dc = symbols('L1 L4 L6 t dxe dye dphie da db dc')
    a = Function('a')
    b = Function('b')
    c = Function('c')
    xe = Function('xe')
    ye = Function('ye')
    phie = Function('phie')

    eqnx = L1*sp.cos(-a(t)) + L4*sp.cos(-a(t)-b(t)) + L6*sp.cos(-a(t)-b(t)-c(t))
    eqny = L1*sp.sin(-a(t)) + L4*sp.sin(-a(t)-b(t)) + L6*sp.sin(-a(t)-b(t)-c(t))
    eqnphi = -a(t)-b(t)-c(t)

    diff_eqnx = sp.diff(eqnx, t).simplify()


    diff_eqny = sp.diff(eqny, t).simplify()



    diff_eqnphi = sp.diff(eqnphi, t).simplify()


    eqnx_lin = Eq(diff_eqnx, dxe)
    eqny_lin = Eq(diff_eqny, dye)
    eqnphi_lin = Eq(diff_eqnphi, dphie)

    eqnx_lin = eqnx_lin.subs([(sp.diff(a(t),t), da), (sp.diff(b(t),t), db), (sp.diff(c(t),t), dc)])
    eqny_lin = eqny_lin.subs([(sp.diff(a(t),t), da), (sp.diff(b(t),t), db), (sp.diff(c(t),t), dc)])
    eqnphi_lin = eqnphi_lin.subs([(sp.diff(a(t),t), da), (sp.diff(b(t),t), db), (sp.diff(c(t),t), dc)])

    jac, ee_vel = sp.linear_eq_to_matrix([eqnx_lin, eqny_lin, eqnphi_lin], [da, db, dc])

    jac = Matrix(jac)

    jac_sub = sp.lambdify([L1,L4,L6,a(t), b(t), c(t)], jac)

    return jac_sub

def move_to_init_pos(valid_limb):
    #joints
    limb = intera_interface.Limb(valid_limb)
    joints = limb.joint_names()

    a = np.deg2rad(-90)
    b = np.deg2rad(90)
    c = np.deg2rad(90)



    thresh = 0.01

    while (abs(limb.joint_angle(joints[1]) - a) > thresh) and (abs(limb.joint_angle(joints[3]) - b) > thresh) and (abs(limb.joint_angle(joints[5]) - c) > thresh):
        rospy.sleep(1.0)
        joint_command = {joints[0]: 0.0, joints[1]: a, joints[2]: 0.0, 
                                joints[3]: b, joints[4]: 0.0, joints[5]: c, joints[6]: 1.70} #0 is base
        limb.set_joint_positions(joint_command)
    
    print('ready')


def main():
    print('ok')

    rospy.init_node('sawyer_move')
    r = rospy.Rate(10)


    sm = SawyerMove()

    pygame.init()
    screen = pygame.display.set_mode((100,100))

    #gripper
    rp = intera_interface.RobotParams()
    valid_limbs = rp.get_limb_names()
    print("Getting robot state...")
    rs = intera_interface.RobotEnable(CHECK_VERSION)
    init_state = rs.state()
    gripper = None
    gripper = intera_interface.Gripper(valid_limbs[0] + '_gripper')
    gripper.set_cmd_velocity(gripper.MAX_VELOCITY)
    close_pos = 0.016
    open_pos = 0.10
    gripper.set_position(close_pos)




    move_to_init_pos(valid_limbs[0])

    jac_f = calculate_jac()



    while not rospy.is_shutdown():
        for event in pygame.event.get():

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_w:
                    
                    #print("move up")
                    ...
                if event.key == pygame.K_s:
                    #print("move down")
                    ...

                if event.key == pygame.K_q:
                    gripper.open()
                    rospy.sleep(0.5)
                    gripper.close()

        keys_pressed = pygame.key.get_pressed()
        if keys_pressed[pygame.K_w]:
            print("move up")

            sm.move_up(jac_f)
        if keys_pressed[pygame.K_s]:
            print("move_down")
            
            sm.move_down(jac_f)

        r.sleep()




if __name__ == '__main__':
    main()