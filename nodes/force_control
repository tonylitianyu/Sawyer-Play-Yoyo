#!/usr/bin/env python3


import argparse

import rospy
import numpy as np
from intera_core_msgs.msg import JointCommand
import intera_external_devices
import intera_interface
import intera_control
from intera_interface import CHECK_VERSION
from sensor_msgs.msg import JointState
from std_msgs.msg import Header, Float32, Int8
from std_srvs.srv import Empty, EmptyResponse
from sawyer_move.msg import YoyoState, RobotControl
from sawyer_move.msg import RobotState
import pygame


import PyKDL as kdl
import kdl_parser_py.urdf as kdl_parser

import time



class SawyerMove:

    def __init__(self, robot_origin_from_ground) -> None:
        self.start_flag = False
        self.start_pub = rospy.Publisher('start', Int8, queue_size=10)

        #self.yoyo_vel_sub = rospy.Subscriber('yoyo_vel', Float32, self.vel_callback)
        self.yoyo_state_sub = rospy.Subscriber('yoyo_state', YoyoState, self.state_callback)

        self.yoyo_rot = 0.0
        self.yoyo_rotvel = 0.0
        
        self.joint_state_sub = rospy.Subscriber('/robot/joint_states', JointState, self.jss_callback)
        self.joint_action_pub = rospy.Publisher('/robot/limb/right/joint_command', JointCommand, queue_size=10)

        self.robot_control_sub = rospy.Subscriber('robot_control', RobotControl, self.control_callback)
        self.robot_state_pub = rospy.Publisher('robot_state', RobotState, queue_size=10)
        #self.ee_z_pos_pub = rospy.Publisher('ee_z_pos', Float32, queue_size=10)
        self.ee_z_pos = 1.58
        self.robot_origin_from_ground = robot_origin_from_ground
        #self.start_srv = rospy.Service("start", Empty, self.start_callback)
        self.curr_joint_pos = np.zeros(9)
        self.joint_names = []


        self.timer = time.time()
        self.move_mag = 1.0
        self.torque_mag = 0.0
        self.vel_mag = 0.0
        self.yc = 0.4
        self.xc = 0.4

        
        self.adjust = 0

        self.preparing_joint = True

        self.setup_jac()


    def setup_jac(self):
        # load in ros parameters
        self.baselink = rospy.get_param("sawyer/baselink")
        self.endlink = rospy.get_param("sawyer/endlink")
        flag, self.tree = kdl_parser.treeFromParam("/robot_description")

        self.joint_names = rospy.get_param("named_poses/right/joint_names")
        print (self.joint_names)

        # build kinematic chain and fk and jacobian solvers
        chain_ee = self.tree.getChain(self.baselink, self.endlink)
        self.fk_ee = kdl.ChainFkSolverPos_recursive(chain_ee)
        self.jac_ee = kdl.ChainJntToJacSolver(chain_ee)

        # building robot joint state
        self.num_joints = chain_ee.getNrOfJoints()
        self.joints = kdl.JntArray(self.num_joints)




        self.jac_mat = []



    def kdl_to_mat(self, m):
        mat =  np.mat(np.zeros((m.rows(), m.columns())))
        for i in range(m.rows()):
            for j in range(m.columns()):
                mat[i,j] = m[i,j]
        return np.array(mat)


    def state_callback(self, data):
        self.yoyo_rot = data.yoyo_rot
        self.yoyo_rotvel = data.yoyo_rotvel

    def control_callback(self, data):
        self.torque_mag = data.ee_z_vel

    def jss_callback(self, data):
        self.curr_joint_pos = data.position

        #self.joint_names = data.name

        if self.start_flag:

            if len(data.name) > 1:
                for i, n in enumerate(self.joint_names):
                    index = data.name.index(n)
                    self.joints[i] = data.position[index]

            frame = kdl.Frame()
            self.fk_ee.JntToCart(self.joints, frame)
            # print(" ")
            # print("position: ")
            # print(frame.p)
            # print("orientation")
            # print(frame.M)
            # print(" ")
            

            self.ee_z_pos = frame.p[2] + self.robot_origin_from_ground



            # if self.adjust == 0 and frame.p[2] > 0.75:
            #     self.adjust = 1

            # if self.adjust == 1 and abs(frame.p[2] - 0.587) < 0.08 and abs(frame.p[2] - 0.587) > 0.01:
            #     self.adjust = 2


            # if abs(frame.p[2] - 0.587) < 0.01:
            #     self.adjust = 0
            
            # # if frame.p[2] < 0.60:
            # #     self.torque_mag = 0.01#0.22



            jacobian = kdl.Jacobian(self.num_joints)
            self.jac_ee.JntToJac(self.joints, jacobian)

            self.jac_mat = self.kdl_to_mat(jacobian)
        


    def init_joints(self):
        if len(list(self.curr_joint_pos)) > 2:  #?????why would there be empty
            a = np.deg2rad(-90)
            b = np.deg2rad(90)
            c = np.deg2rad(90)

            goal_joints = [0.0, a, 0.0, b, 0.0, c, 1.70]



            jc_pos = JointCommand()
            jc_pos.mode = 1
            jc_pos.names = self.joint_names
            jc_pos.position = goal_joints
            self.joint_action_pub.publish(jc_pos)
            
            curr_joint_arr = np.array(list(self.curr_joint_pos))[1:8]
            

            if np.allclose(goal_joints, curr_joint_arr, atol=0.01):
                print("ready")
                self.preparing_joint = False



    def loop(self):
        if self.start_flag:

            #if self.adjust == 0 and self.yoyo_rot < 50 and self.yoyo_rotvel < 0.0:
            self.vel_mag = self.torque_mag

            inv_jac = np.linalg.pinv(self.jac_mat)

            ee_vel_val = np.array([0.0, 0.0, self.vel_mag, 0.0, 0.0, 0.0]).reshape(-1,1)
            joint_vel_val = (inv_jac@ee_vel_val).flatten()


            jc = JointCommand()
            jc.mode = 2
            jc.names = self.joint_names
            jc.velocity = joint_vel_val
            self.joint_action_pub.publish(jc)   

            # elif self.adjust == 1:
            #     inv_jac = np.linalg.pinv(self.jac_mat)

            #     ee_vel_val = np.array([0.0, 0.0, -0.35, 0.0, 0.0, 0.0]).reshape(-1,1)
            #     joint_vel_val = (inv_jac@ee_vel_val).flatten()
            #     jc = JointCommand()
            #     jc.mode = 2
            #     jc.names = self.joint_names
            #     jc.velocity = joint_vel_val
            #     self.joint_action_pub.publish(jc) 


            # elif self.adjust == 2:
            #     self.vel_mag = 0.0
            #     jc_pos = JointCommand()
            #     jc_pos.mode = 1

            #     a = np.deg2rad(-90)
            #     b = np.deg2rad(90)
            #     c = np.deg2rad(90)

            #     goal_joints = [0.0, a, 0.0, b, 0.0, c, 1.70]
            #     jc_pos.names = self.joint_names
            #     jc_pos.position = goal_joints
            #     self.joint_action_pub.publish(jc_pos)


            #     #self.adjust = 2


            robot_state = RobotState()
            robot_state.ee_z_pos = self.ee_z_pos
            robot_state.ee_z_vel = self.vel_mag
            self.robot_state_pub.publish(robot_state)


            if self.ee_z_pos > 1.40:
                self.start_pub.publish(Int8(1))
            else:
                self.start_pub.publish(Int8(0))




def main():
    print('ok')

    rospy.init_node('sawyer_move')
    r = rospy.Rate(100)

    robot_origin_from_ground = rospy.get_param("robot_origin_from_ground")
    sm = SawyerMove(robot_origin_from_ground)

    pygame.init()
    screen = pygame.display.set_mode((100,100))

    #gripper
    rp = intera_interface.RobotParams()
    valid_limbs = rp.get_limb_names()
    print("Getting robot state...")
    rs = intera_interface.RobotEnable(CHECK_VERSION)
    init_state = rs.state()
    gripper = None
    gripper = intera_interface.Gripper(valid_limbs[0] + '_gripper')
    gripper.set_cmd_velocity(gripper.MAX_VELOCITY)
    gripper.set_position(0.010)
    close_pos = 0.021
    open_pos = 0.10
    gripper.set_position(close_pos)

#0.371, #0.158
#0.5cm


    #task_init(valid_limbs[0])

    sm.init_joints()



    while not rospy.is_shutdown():

        if sm.preparing_joint:
            sm.init_joints()

        else:
            for event in pygame.event.get():

                if event.type == pygame.KEYDOWN:

                    if event.key == pygame.K_q:
                        sm.start_flag = True
                        gripper.open()
                        rospy.sleep(0.3)
                        gripper.close()
                        sm.torque_mag = 0.0#0.07

            keys_pressed = pygame.key.get_pressed()

            if keys_pressed[pygame.K_z]:
                sm.torque_mag = 0.0

            sm.loop()
        r.sleep()




if __name__ == '__main__':
    main()